import $8c5bX$clonedeep from "clone-deep";
import $8c5bX$events from "events";
import {v4 as $8c5bX$v4} from "uuid";


function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
var $d881613f2029ce0c$exports = {};

$parcel$export($d881613f2029ce0c$exports, "httpActionGenerator", () => $d881613f2029ce0c$export$8728b60ea57bf43e);

async function $d881613f2029ce0c$export$8728b60ea57bf43e(actionUrl, action, params, handleResponse) {
    try {
        console.debug("[RTVI] Fetch action", actionUrl, action);
        const headers = new Headers({
            ...Object.fromEntries((params.headers ?? new Headers()).entries())
        });
        if (!headers.has("Content-Type")) headers.set("Content-Type", "application/json");
        headers.set("Cache-Control", "no-cache");
        headers.set("Connection", "keep-alive");
        // Perform the fetch request
        const response = await fetch(actionUrl, {
            method: "POST",
            headers: headers,
            body: JSON.stringify({
                ...params.requestData,
                actions: [
                    action
                ]
            })
        });
        // Check the response content type
        const contentType = response.headers.get("content-type");
        // Handle non-ok response status
        if (!response.ok) {
            const errorMessage = await response.text();
            throw new (0, $08bedc6ef0d1c66c$export$59b4786f333aac02)(`Failed to resolve action: ${errorMessage}`, response.status);
        }
        if (response.body && contentType?.includes("text/event-stream")) {
            // Parse streamed responses
            const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
            let buffer = "";
            while(true){
                const { value: value, done: done } = await reader.read();
                if (done) break;
                buffer += value;
                let boundary = buffer.indexOf("\n\n");
                while(boundary !== -1){
                    const message = buffer.slice(0, boundary);
                    buffer = buffer.slice(boundary + 2);
                    // Split on the first ":" to extract the JSON part
                    const lines = message.split("\n");
                    let encodedData = "";
                    for (const line of lines){
                        const colonIndex = line.indexOf(":");
                        if (colonIndex !== -1) encodedData += line.slice(colonIndex + 1).trim();
                    }
                    try {
                        const jsonData = atob(encodedData);
                        const parsedData = JSON.parse(jsonData);
                        handleResponse(parsedData);
                    } catch (error) {
                        console.error("[RTVI] Failed to parse JSON:", error);
                        throw error;
                    }
                    boundary = buffer.indexOf("\n\n");
                }
            }
        } else {
            // For regular non-streamed responses, parse and handle the data as JSON
            const data = await response.json();
            handleResponse(data);
        }
    } catch (error) {
        console.error("[RTVI] Error during fetch:", error);
        throw error;
    }
} /*
//@TODO: implement abortController when mode changes / bad things happen
export async function dispatchAction(
  this: RTVIClient,
  action: RTVIActionRequest
): Promise<RTVIActionResponse> {
  const promise = new Promise((resolve, reject) => {
    (async () => {
      if (this.connected) {
        return this._messageDispatcher.dispatch(action);
      } else {
        const actionUrl = this.constructUrl("action");
        try {
          const result = await httpActionGenerator(
            actionUrl,
            action,
            this.params,
            (response) => {
              this.handleMessage(response);
            }
          );
          resolve(result);
        } catch (error) {
          reject(error);
        }
      }
    })();
  });

  return promise as Promise<RTVIActionResponse>;
}
*/ 


var $74c1449bc91bda44$exports = {};

$parcel$export($74c1449bc91bda44$exports, "RTVIClient", () => $74c1449bc91bda44$export$fa42a01c1d60f4a1);


var $a2e2958c9fde306f$exports = {};
$a2e2958c9fde306f$exports = JSON.parse('{"name":"realtime-ai","version":"0.2.1","license":"BSD-2-Clause","main":"dist/index.js","module":"dist/index.module.js","types":"dist/index.d.ts","source":"src/index.ts","repository":{"type":"git","url":"git+https://github.com/rtvi-ai/rtvi-client-web.git"},"files":["dist","package.json","README.md"],"scripts":{"build":"jest --silent && parcel build --no-cache","dev":"parcel watch","lint":"eslint src/ --report-unused-disable-directives --max-warnings 0","test":"jest"},"jest":{"preset":"ts-jest","testEnvironment":"node"},"devDependencies":{"@jest/globals":"^29.7.0","@types/clone-deep":"^4.0.4","@types/jest":"^29.5.12","@types/uuid":"^10.0.0","@typescript-eslint/eslint-plugin":"^7.16.0","@typescript-eslint/parser":"^7.16.0","eslint":"9.11.1","eslint-config-prettier":"^9.1.0","eslint-plugin-simple-import-sort":"^12.1.1","jest":"^29.7.0","ts-jest":"^29.2.5"},"dependencies":{"@types/events":"^3.0.3","clone-deep":"^4.0.1","events":"^3.3.0","typed-emitter":"^2.1.0","uuid":"^10.0.0"}}');


var $08bedc6ef0d1c66c$exports = {};

$parcel$export($08bedc6ef0d1c66c$exports, "RTVIError", () => $08bedc6ef0d1c66c$export$59b4786f333aac02);
$parcel$export($08bedc6ef0d1c66c$exports, "ConnectionTimeoutError", () => $08bedc6ef0d1c66c$export$c67992fa684a81a6);
$parcel$export($08bedc6ef0d1c66c$exports, "StartBotError", () => $08bedc6ef0d1c66c$export$e7544ab812238a61);
$parcel$export($08bedc6ef0d1c66c$exports, "TransportStartError", () => $08bedc6ef0d1c66c$export$e0624a511a2c4e9);
$parcel$export($08bedc6ef0d1c66c$exports, "BotNotReadyError", () => $08bedc6ef0d1c66c$export$885fb96b850e8fbb);
$parcel$export($08bedc6ef0d1c66c$exports, "ConfigUpdateError", () => $08bedc6ef0d1c66c$export$4eda4fd287fbbca5);
$parcel$export($08bedc6ef0d1c66c$exports, "VoiceError", () => $08bedc6ef0d1c66c$export$975d7330b0c579b7);
class $08bedc6ef0d1c66c$export$59b4786f333aac02 extends Error {
    constructor(message, status){
        super(message);
        this.status = status;
    }
}
class $08bedc6ef0d1c66c$export$c67992fa684a81a6 extends $08bedc6ef0d1c66c$export$59b4786f333aac02 {
    constructor(message){
        super(message ?? "Bot did not enter ready state within the specified timeout period.");
    }
}
class $08bedc6ef0d1c66c$export$e7544ab812238a61 extends $08bedc6ef0d1c66c$export$59b4786f333aac02 {
    constructor(message, status){
        super(message ?? `Failed to connect / invalid auth bundle from base url`, status ?? 500);
        this.error = "invalid-request-error";
    }
}
class $08bedc6ef0d1c66c$export$e0624a511a2c4e9 extends $08bedc6ef0d1c66c$export$59b4786f333aac02 {
    constructor(message){
        super(message ?? "Unable to connect to transport");
    }
}
class $08bedc6ef0d1c66c$export$885fb96b850e8fbb extends $08bedc6ef0d1c66c$export$59b4786f333aac02 {
    constructor(message){
        super(message ?? "Attempt to call action on transport when not in 'ready' state.");
    }
}
class $08bedc6ef0d1c66c$export$4eda4fd287fbbca5 extends $08bedc6ef0d1c66c$export$59b4786f333aac02 {
    constructor(message){
        super(message ?? "Unable to update configuration");
        this.status = 400;
    }
}
class $08bedc6ef0d1c66c$export$975d7330b0c579b7 extends $08bedc6ef0d1c66c$export$59b4786f333aac02 {
}


function $9e3641858ff8efee$export$f1586721024c4dab(_target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = function(...args) {
        if (this.state === "ready") return originalMethod.apply(this, args);
        else throw new (0, $08bedc6ef0d1c66c$export$885fb96b850e8fbb)(`Attempt to call ${propertyKey.toString()} when transport not in ready state. Await connect() first.`);
    };
    return descriptor;
}
function $9e3641858ff8efee$export$808994d0d8c9acb3(states) {
    return function(_target, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        descriptor.get = function(...args) {
            if (states.includes(this.state)) return originalMethod.apply(this, args);
            else throw new (0, $08bedc6ef0d1c66c$export$885fb96b850e8fbb)(`Attempt to call ${propertyKey.toString()} when transport not in ${states}.`);
        };
        return descriptor;
    };
}
function $9e3641858ff8efee$export$5c35b4fe6fa8c9a6(...states) {
    states = [
        "ready",
        ...states
    ];
    return function(_target, propertyKey, descriptor) {
        const originalGetter = descriptor.get;
        descriptor.get = function() {
            if (states.includes(this.state)) return originalGetter?.apply(this);
            else throw new (0, $08bedc6ef0d1c66c$export$885fb96b850e8fbb)(`Attempt to call ${propertyKey.toString()} when transport not in ${states}. Await connect() first.`);
        };
        return descriptor;
    };
}



var $cbe8e0de0049ed6e$exports = {};

$parcel$export($cbe8e0de0049ed6e$exports, "RTVIEvent", () => $cbe8e0de0049ed6e$export$6b4624d233c61fcb);
var $cbe8e0de0049ed6e$export$6b4624d233c61fcb;
(function(RTVIEvent) {
    RTVIEvent["MessageError"] = "messageError";
    RTVIEvent["Error"] = "error";
    RTVIEvent["Connected"] = "connected";
    RTVIEvent["Disconnected"] = "disconnected";
    RTVIEvent["TransportStateChanged"] = "transportStateChanged";
    RTVIEvent["Config"] = "config";
    RTVIEvent["ConfigDescribe"] = "configDescribe";
    RTVIEvent["ActionsAvailable"] = "actionsAvailable";
    RTVIEvent["ParticipantConnected"] = "participantConnected";
    RTVIEvent["ParticipantLeft"] = "participantLeft";
    RTVIEvent["TrackStarted"] = "trackStarted";
    RTVIEvent["TrackedStopped"] = "trackStopped";
    RTVIEvent["AvailableCamsUpdated"] = "availableCamsUpdated";
    RTVIEvent["AvailableMicsUpdated"] = "availableMicsUpdated";
    RTVIEvent["CamUpdated"] = "camUpdated";
    RTVIEvent["MicUpdated"] = "micUpdated";
    RTVIEvent["BotConnected"] = "botConnected";
    RTVIEvent["BotReady"] = "botReady";
    RTVIEvent["BotDisconnected"] = "botDisconnected";
    RTVIEvent["BotStartedSpeaking"] = "botStartedSpeaking";
    RTVIEvent["BotStoppedSpeaking"] = "botStoppedSpeaking";
    RTVIEvent["RemoteAudioLevel"] = "remoteAudioLevel";
    RTVIEvent["UserStartedSpeaking"] = "userStartedSpeaking";
    RTVIEvent["UserStoppedSpeaking"] = "userStoppedSpeaking";
    RTVIEvent["LocalAudioLevel"] = "localAudioLevel";
    RTVIEvent["Metrics"] = "metrics";
    RTVIEvent["UserTranscript"] = "userTranscript";
    RTVIEvent["BotTranscript"] = "botTranscript";
    RTVIEvent["BotLlmText"] = "botLlmText";
    RTVIEvent["BotLlmStarted"] = "botLlmStarted";
    RTVIEvent["BotLlmStopped"] = "botLlmStopped";
    RTVIEvent["BotTtsText"] = "botTtsText";
    RTVIEvent["BotTtsStarted"] = "botTtsStarted";
    RTVIEvent["BotTtsStopped"] = "botTtsStopped";
    RTVIEvent["LLMFunctionCall"] = "llmFunctionCall";
    RTVIEvent["LLMFunctionCallStart"] = "llmFunctionCallStart";
    RTVIEvent["LLMJsonCompletion"] = "llmJsonCompletion";
    RTVIEvent["StorageItemStored"] = "storageItemStored";
    /**
     * @deprecated Use BotLlmText instead
     */ RTVIEvent["BotText"] = "botText";
})($cbe8e0de0049ed6e$export$6b4624d233c61fcb || ($cbe8e0de0049ed6e$export$6b4624d233c61fcb = {}));


var $505461462111ea0b$exports = {};

$parcel$export($505461462111ea0b$exports, "RTVIClientHelper", () => $505461462111ea0b$export$23bc637255b2a471);
class $505461462111ea0b$export$23bc637255b2a471 {
    constructor(options){
        this._options = options;
    }
    set client(client) {
        this._client = client;
    }
    set service(service) {
        this._service = service;
    }
}


var $bff4129f8f902365$exports = {};

$parcel$export($bff4129f8f902365$exports, "RTVI_MESSAGE_LABEL", () => $bff4129f8f902365$export$882b13c7fda338f5);
$parcel$export($bff4129f8f902365$exports, "RTVIMessageType", () => $bff4129f8f902365$export$38b3db05cbf0e240);
$parcel$export($bff4129f8f902365$exports, "RTVIMessage", () => $bff4129f8f902365$export$69aa9ab0334b212);
$parcel$export($bff4129f8f902365$exports, "RTVI_ACTION_TYPE", () => $bff4129f8f902365$export$28ad8d0d400d3e2d);
$parcel$export($bff4129f8f902365$exports, "RTVIActionRequest", () => $bff4129f8f902365$export$378529d7a8bead8b);
$parcel$export($bff4129f8f902365$exports, "MessageDispatcher", () => $bff4129f8f902365$export$e9a960646cc432aa);
$parcel$export($bff4129f8f902365$exports, "VoiceMessage", () => $bff4129f8f902365$export$3336fb47fe34a146);


const $bff4129f8f902365$export$882b13c7fda338f5 = "rtvi-ai";
var $bff4129f8f902365$export$38b3db05cbf0e240;
(function(RTVIMessageType) {
    // Outbound
    RTVIMessageType["CLIENT_READY"] = "client-ready";
    RTVIMessageType["UPDATE_CONFIG"] = "update-config";
    RTVIMessageType["GET_CONFIG"] = "get-config";
    RTVIMessageType["DESCRIBE_CONFIG"] = "describe-config";
    RTVIMessageType["DESCRIBE_ACTIONS"] = "describe-actions";
    // Inbound
    RTVIMessageType["BOT_READY"] = "bot-ready";
    RTVIMessageType["ERROR"] = "error";
    RTVIMessageType["ERROR_RESPONSE"] = "error-response";
    RTVIMessageType["CONFIG"] = "config";
    RTVIMessageType["CONFIG_AVAILABLE"] = "config-available";
    RTVIMessageType["CONFIG_ERROR"] = "config-error";
    RTVIMessageType["ACTIONS_AVAILABLE"] = "actions-available";
    RTVIMessageType["ACTION_RESPONSE"] = "action-response";
    RTVIMessageType["METRICS"] = "metrics";
    RTVIMessageType["USER_TRANSCRIPTION"] = "user-transcription";
    RTVIMessageType["BOT_TRANSCRIPTION"] = "bot-transcription";
    RTVIMessageType["USER_STARTED_SPEAKING"] = "user-started-speaking";
    RTVIMessageType["USER_STOPPED_SPEAKING"] = "user-stopped-speaking";
    RTVIMessageType["BOT_STARTED_SPEAKING"] = "bot-started-speaking";
    RTVIMessageType["BOT_STOPPED_SPEAKING"] = "bot-stopped-speaking";
    // Service-specific
    RTVIMessageType["USER_LLM_TEXT"] = "user-llm-text";
    RTVIMessageType["BOT_LLM_TEXT"] = "bot-llm-text";
    RTVIMessageType["BOT_LLM_STARTED"] = "bot-llm-started";
    RTVIMessageType["BOT_LLM_STOPPED"] = "bot-llm-stopped";
    RTVIMessageType["BOT_TTS_TEXT"] = "bot-tts-text";
    RTVIMessageType["BOT_TTS_STARTED"] = "bot-tts-started";
    RTVIMessageType["BOT_TTS_STOPPED"] = "bot-tts-stopped";
    // Storage
    RTVIMessageType["STORAGE_ITEM_STORED"] = "storage-item-stored";
})($bff4129f8f902365$export$38b3db05cbf0e240 || ($bff4129f8f902365$export$38b3db05cbf0e240 = {}));
class $bff4129f8f902365$export$69aa9ab0334b212 {
    constructor(type, data, id){
        this.label = $bff4129f8f902365$export$882b13c7fda338f5;
        this.type = type;
        this.data = data;
        this.id = id || (0, $8c5bX$v4)().slice(0, 8);
    }
    // Outbound message types
    static clientReady() {
        return new $bff4129f8f902365$export$69aa9ab0334b212($bff4129f8f902365$export$38b3db05cbf0e240.CLIENT_READY, {});
    }
    static updateConfig(config, interrupt = false) {
        return new $bff4129f8f902365$export$69aa9ab0334b212($bff4129f8f902365$export$38b3db05cbf0e240.UPDATE_CONFIG, {
            config: config,
            interrupt: interrupt
        });
    }
    static describeConfig() {
        return new $bff4129f8f902365$export$69aa9ab0334b212($bff4129f8f902365$export$38b3db05cbf0e240.DESCRIBE_CONFIG, {});
    }
    static getBotConfig() {
        return new $bff4129f8f902365$export$69aa9ab0334b212($bff4129f8f902365$export$38b3db05cbf0e240.GET_CONFIG, {});
    }
    static describeActions() {
        return new $bff4129f8f902365$export$69aa9ab0334b212($bff4129f8f902365$export$38b3db05cbf0e240.DESCRIBE_ACTIONS, {});
    }
}
const $bff4129f8f902365$export$28ad8d0d400d3e2d = "action";
class $bff4129f8f902365$export$378529d7a8bead8b extends $bff4129f8f902365$export$69aa9ab0334b212 {
    constructor(data){
        super($bff4129f8f902365$export$28ad8d0d400d3e2d, data);
    }
}
class $bff4129f8f902365$export$e9a960646cc432aa {
    constructor(client){
        this._queue = new Array();
        this._gcTime = 10000; // How long to wait before resolving the message
        this._queue = [];
        this._client = client;
    }
    dispatch(message) {
        const promise = new Promise((resolve, reject)=>{
            this._queue.push({
                message: message,
                timestamp: Date.now(),
                resolve: resolve,
                reject: reject
            });
        });
        console.debug("[MessageDispatcher] dispatch", message);
        this._client.sendMessage(message);
        this._gc();
        return promise;
    }
    async dispatchAction(action, onMessage) {
        const promise = new Promise((resolve, reject)=>{
            this._queue.push({
                message: action,
                timestamp: Date.now(),
                resolve: resolve,
                reject: reject
            });
        });
        console.debug("[MessageDispatcher] action", action);
        if (this._client.connected) // Send message to transport when connected
        this._client.sendMessage(action);
        else {
            const actionUrl = this._client.constructUrl("action");
            try {
                // Dispatch action via HTTP when disconnected
                await (0, $d881613f2029ce0c$export$8728b60ea57bf43e)(actionUrl, action, this._client.params, (response)=>{
                    onMessage(response);
                });
            // On HTTP success (resolve), send `action` message (for callbacks)
            } catch (e) {
                onMessage(new $bff4129f8f902365$export$69aa9ab0334b212($bff4129f8f902365$export$38b3db05cbf0e240.ERROR_RESPONSE, `Action endpoint '${actionUrl}' returned an error response`, action.id));
            }
        }
        this._gc();
        return promise;
    }
    _resolveReject(message, resolve = true) {
        const queuedMessage = this._queue.find((msg)=>msg.message.id === message.id);
        if (queuedMessage) {
            if (resolve) {
                console.debug("[MessageDispatcher] Resolve", message);
                queuedMessage.resolve(message.type === $bff4129f8f902365$export$38b3db05cbf0e240.ACTION_RESPONSE ? message : message);
            } else {
                console.debug("[MessageDispatcher] Reject", message);
                queuedMessage.reject(message);
            }
            // Remove message from queue
            this._queue = this._queue.filter((msg)=>msg.message.id !== message.id);
            console.debug("[MessageDispatcher] Queue", this._queue);
        }
        return message;
    }
    resolve(message) {
        return this._resolveReject(message, true);
    }
    reject(message) {
        return this._resolveReject(message, false);
    }
    _gc() {
        this._queue = this._queue.filter((msg)=>{
            return Date.now() - msg.timestamp < this._gcTime;
        });
        console.debug("[MessageDispatcher] GC", this._queue);
    }
}
class $bff4129f8f902365$export$3336fb47fe34a146 extends $bff4129f8f902365$export$69aa9ab0334b212 {
}


var $74c1449bc91bda44$var$__decorate = undefined && undefined.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const $74c1449bc91bda44$var$defaultEndpoints = {
    connect: "/connect",
    action: "/action"
};
class $74c1449bc91bda44$var$RTVIEventEmitter extends (0, $8c5bX$events) {
}
class $74c1449bc91bda44$export$fa42a01c1d60f4a1 extends $74c1449bc91bda44$var$RTVIEventEmitter {
    constructor(options){
        super();
        this.params = {
            ...options.params,
            endpoints: {
                ...$74c1449bc91bda44$var$defaultEndpoints,
                ...options.params.endpoints ?? {}
            }
        };
        this._helpers = {};
        this._transport = options.transport;
        // Wrap transport callbacks with event triggers
        // This allows for either functional callbacks or .on / .off event listeners
        const wrappedCallbacks = {
            ...options.callbacks,
            onMessageError: (message)=>{
                options?.callbacks?.onMessageError?.(message);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).MessageError, message);
            },
            onError: (message)=>{
                options?.callbacks?.onError?.(message);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).Error, message);
            },
            onConnected: ()=>{
                options?.callbacks?.onConnected?.();
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).Connected);
            },
            onDisconnected: ()=>{
                options?.callbacks?.onDisconnected?.();
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).Disconnected);
            },
            onTransportStateChanged: (state)=>{
                options?.callbacks?.onTransportStateChanged?.(state);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).TransportStateChanged, state);
            },
            onConfig: (config)=>{
                options?.callbacks?.onConfig?.(config);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).Config, config);
            },
            onConfigDescribe: (configDescription)=>{
                options?.callbacks?.onConfigDescribe?.(configDescription);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).ConfigDescribe, configDescription);
            },
            onActionsAvailable: (actionsAvailable)=>{
                options?.callbacks?.onActionsAvailable?.(actionsAvailable);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).ActionsAvailable, actionsAvailable);
            },
            onParticipantJoined: (p)=>{
                options?.callbacks?.onParticipantJoined?.(p);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).ParticipantConnected, p);
            },
            onParticipantLeft: (p)=>{
                options?.callbacks?.onParticipantLeft?.(p);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).ParticipantLeft, p);
            },
            onTrackStarted: (track, p)=>{
                options?.callbacks?.onTrackStarted?.(track, p);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).TrackStarted, track, p);
            },
            onTrackStopped: (track, p)=>{
                options?.callbacks?.onTrackStopped?.(track, p);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).TrackedStopped, track, p);
            },
            onAvailableCamsUpdated: (cams)=>{
                options?.callbacks?.onAvailableCamsUpdated?.(cams);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).AvailableCamsUpdated, cams);
            },
            onAvailableMicsUpdated: (mics)=>{
                options?.callbacks?.onAvailableMicsUpdated?.(mics);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).AvailableMicsUpdated, mics);
            },
            onCamUpdated: (cam)=>{
                options?.callbacks?.onCamUpdated?.(cam);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).CamUpdated, cam);
            },
            onMicUpdated: (mic)=>{
                options?.callbacks?.onMicUpdated?.(mic);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).MicUpdated, mic);
            },
            onBotConnected: (p)=>{
                options?.callbacks?.onBotConnected?.(p);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).BotConnected, p);
            },
            onBotReady: (botReadyData)=>{
                options?.callbacks?.onBotReady?.(botReadyData);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).BotReady, botReadyData);
            },
            onBotDisconnected: (p)=>{
                options?.callbacks?.onBotDisconnected?.(p);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).BotDisconnected, p);
            },
            onBotStartedSpeaking: ()=>{
                options?.callbacks?.onBotStartedSpeaking?.();
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).BotStartedSpeaking);
            },
            onBotStoppedSpeaking: ()=>{
                options?.callbacks?.onBotStoppedSpeaking?.();
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).BotStoppedSpeaking);
            },
            onRemoteAudioLevel: (level, p)=>{
                options?.callbacks?.onRemoteAudioLevel?.(level, p);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).RemoteAudioLevel, level, p);
            },
            onUserStartedSpeaking: ()=>{
                options?.callbacks?.onUserStartedSpeaking?.();
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).UserStartedSpeaking);
            },
            onUserStoppedSpeaking: ()=>{
                options?.callbacks?.onUserStoppedSpeaking?.();
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).UserStoppedSpeaking);
            },
            onLocalAudioLevel: (level)=>{
                options?.callbacks?.onLocalAudioLevel?.(level);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).LocalAudioLevel, level);
            },
            onUserTranscript: (data)=>{
                options?.callbacks?.onUserTranscript?.(data);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).UserTranscript, data);
            },
            onBotTranscript: (text)=>{
                options?.callbacks?.onBotTranscript?.(text);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).BotTranscript, text);
            },
            onBotLlmText: (text)=>{
                options?.callbacks?.onBotLlmText?.(text);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).BotLlmText, text);
            },
            onBotLlmStarted: ()=>{
                options?.callbacks?.onBotLlmStarted?.();
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).BotLlmStarted);
            },
            onBotLlmStopped: ()=>{
                options?.callbacks?.onBotLlmStopped?.();
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).BotLlmStopped);
            },
            onBotTtsText: (text)=>{
                options?.callbacks?.onBotTtsText?.(text);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).BotTtsText, text);
            },
            onBotTtsStarted: ()=>{
                options?.callbacks?.onBotTtsStarted?.();
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).BotTtsStarted);
            },
            onBotTtsStopped: ()=>{
                options?.callbacks?.onBotTtsStopped?.();
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).BotTtsStopped);
            },
            onStorageItemStored: (data)=>{
                options?.callbacks?.onStorageItemStored?.(data);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).StorageItemStored, data);
            },
            /**
             * @deprecated Use BotLlmText instead
             */ onBotText: (text)=>{
                options?.callbacks?.onBotText?.(text);
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).BotText, text);
            }
        };
        // Update options to reference wrapped callbacks and config defaults
        this._options = {
            ...options,
            callbacks: wrappedCallbacks,
            enableMic: options.enableMic ?? true,
            enableCam: options.enableCam ?? false
        };
        // Instantiate the transport class and bind message handler
        this._initialize();
        // Get package version number
        console.debug("[RTVI Client] Initialized", this.version);
    }
    constructUrl(endpoint) {
        if (!this.params.baseUrl) throw new $08bedc6ef0d1c66c$export$59b4786f333aac02("Base URL not set. Please set rtviClient.params.baseUrl");
        const baseUrl = this.params.baseUrl.replace(/\/+$/, "");
        return baseUrl + (this.params.endpoints?.[endpoint] ?? "");
    }
    // ------ Transport methods
    /**
     * Initialize local media devices
     */ async initDevices() {
        console.debug("[RTVI Client] Initializing devices...");
        await this._transport.initDevices();
    }
    /**
     * Connect the voice client session with chosen transport
     * Call async (await) to handle errors
     */ async connect() {
        if ([
            "authenticating",
            "connecting",
            "connected",
            "ready"
        ].includes(this._transport.state)) throw new $08bedc6ef0d1c66c$export$59b4786f333aac02("Voice client has already been started. Please call disconnect() before starting again.");
        this._abortController = new AbortController();
        // Establish transport session and await bot ready signal
        return new Promise((resolve, reject)=>{
            (async ()=>{
                this._startResolve = resolve;
                if (this._transport.state === "disconnected") await this._transport.initDevices();
                this._transport.state = "authenticating";
                // Set a timer for the bot to enter a ready state, otherwise abort the attempt
                if (this._options.timeout) this._handshakeTimeout = setTimeout(async ()=>{
                    this._abortController?.abort();
                    await this.disconnect();
                    this._transport.state = "error";
                    reject(new $08bedc6ef0d1c66c$export$c67992fa684a81a6());
                }, this._options.timeout);
                let authBundle;
                const customConnectHandler = this._options.customConnectHandler;
                const connectUrl = this.constructUrl("connect");
                this.params = {
                    ...this.params,
                    requestData: {
                        ...this.params.requestData,
                        rtvi_client_version: this.version
                    }
                };
                console.debug("[RTVI Client] Connecting...", connectUrl);
                console.debug("[RTVI Client] Start params", this.params);
                try {
                    if (customConnectHandler) authBundle = await customConnectHandler(this.params, this._handshakeTimeout, this._abortController);
                    else authBundle = await fetch(connectUrl, {
                        method: "POST",
                        mode: "cors",
                        headers: new Headers({
                            "Content-Type": "application/json",
                            ...Object.fromEntries((this.params.headers ?? new Headers()).entries())
                        }),
                        body: JSON.stringify({
                            services: this._options.services,
                            config: this.params.config ?? this._options.config,
                            ...this._options.customBodyParams,
                            ...this.params.requestData
                        }),
                        signal: this._abortController?.signal
                    }).then((res)=>{
                        clearTimeout(this._handshakeTimeout);
                        if (res.ok) return res.json();
                        return Promise.reject(res);
                    });
                } catch (e) {
                    clearTimeout(this._handshakeTimeout);
                    // Handle errors if the request was not aborted
                    if (this._abortController?.signal.aborted) return;
                    this._transport.state = "error";
                    if (e instanceof Response) {
                        const errorResp = await e.json();
                        reject(new $08bedc6ef0d1c66c$export$e7544ab812238a61(errorResp.info ?? errorResp.detail ?? e.statusText, e.status));
                    } else reject(new $08bedc6ef0d1c66c$export$e7544ab812238a61());
                    return;
                }
                console.debug("[RTVI Client] Auth bundle received", authBundle);
                try {
                    await this._transport.connect(authBundle, this._abortController);
                } catch (e) {
                    clearTimeout(this._handshakeTimeout);
                    reject(e);
                    return;
                }
                await this._transport.sendReadyMessage();
            })();
        });
    }
    /**
     * Disconnect the voice client from the transport
     * Reset / reinitialize transport and abort any pending requests
     */ async disconnect() {
        if (this._abortController) this._abortController.abort();
        clearTimeout(this._handshakeTimeout);
        await this._transport.disconnect();
        this._initialize();
    }
    _initialize() {
        // Reset transport
        this._transport = this._options.transport;
        this._transport.initialize(this._options, this.handleMessage.bind(this));
        // Create a new message dispatch queue for async message handling
        this._messageDispatcher = new (0, $bff4129f8f902365$export$e9a960646cc432aa)(this);
    }
    /**
     * Get the current state of the transport
     */ get connected() {
        return [
            "connected",
            "ready"
        ].includes(this._transport.state);
    }
    get state() {
        return this._transport.state;
    }
    get version() {
        return (0, (/*@__PURE__*/$parcel$interopDefault($a2e2958c9fde306f$exports))).version;
    }
    // ------ Device methods
    async getAllMics() {
        return await this._transport.getAllMics();
    }
    async getAllCams() {
        return await this._transport.getAllCams();
    }
    get selectedMic() {
        return this._transport.selectedMic;
    }
    get selectedCam() {
        return this._transport.selectedCam;
    }
    updateMic(micId) {
        this._transport.updateMic(micId);
    }
    updateCam(camId) {
        this._transport.updateCam(camId);
    }
    enableMic(enable) {
        this._transport.enableMic(enable);
    }
    get isMicEnabled() {
        return this._transport.isMicEnabled;
    }
    enableCam(enable) {
        this._transport.enableCam(enable);
    }
    get isCamEnabled() {
        return this._transport.isCamEnabled;
    }
    tracks() {
        return this._transport.tracks();
    }
    // ------ Config methods
    /**
     * Request the bot to send the current configuration
     * @returns Promise<RTVIClientConfigOption[]> - Promise that resolves with the bot's configuration
     */ async getConfig() {
        const configMsg = await this._messageDispatcher.dispatch((0, $bff4129f8f902365$export$69aa9ab0334b212).getBotConfig());
        return configMsg.data.config;
    }
    /**
     * Update pipeline and services
     * @param config - RTVIClientConfigOption[] partial object with the new configuration
     * @param interrupt - boolean flag to interrupt the current pipeline, or wait until the next turn
     * @returns Promise<RTVIMessage> - Promise that resolves with the updated configuration
     */ async updateConfig(config, interrupt = false) {
        console.debug("[RTVI Client] Updating config", config);
        // Only send the partial config if the bot is ready to prevent
        // potential racing conditions whilst pipeline is instantiating
        return this._messageDispatcher.dispatch((0, $bff4129f8f902365$export$69aa9ab0334b212).updateConfig(config, interrupt));
    }
    /**
     * Request bot describe the current configuration options
     * @returns Promise<unknown> - Promise that resolves with the bot's configuration description
     */ async describeConfig() {
        return this._messageDispatcher.dispatch((0, $bff4129f8f902365$export$69aa9ab0334b212).describeConfig());
    }
    /**
     * Returns configuration options for specified service key
     * @param serviceKey - Service name to get options for (e.g. "llm")
     * @param config? - Optional RTVIClientConfigOption[] to query (vs. using remote config)
     * @returns RTVIClientConfigOption | undefined - Configuration options array for the service with specified key or undefined
     */ async getServiceOptionsFromConfig(serviceKey, config) {
        if (!config && this.state !== "ready") throw new $08bedc6ef0d1c66c$export$885fb96b850e8fbb("getServiceOptionsFromConfig called without config array before bot is ready");
        return Promise.resolve().then(async ()=>{
            // Check if we have registered service with name service
            if (!serviceKey) {
                console.debug("Target service name is required");
                return undefined;
            }
            const passedConfig = config ?? await this.getConfig();
            // Find matching service name in the config and update the messages
            const configServiceKey = passedConfig.find((config)=>config.service === serviceKey);
            if (!configServiceKey) {
                console.debug("No service with name " + serviceKey + " not found in config");
                return undefined;
            }
            // Return a new object, as to not mutate existing state
            return configServiceKey;
        });
    }
    /**
     * Returns configuration option value (unknown) for specified service key and option name
     * @param serviceKey - Service name to get options for (e.g. "llm")
     * @optional option Name of option return from the config (e.g. "model")
     * @returns Promise<unknown | undefined> - Service configuration option value or undefined
     */ async getServiceOptionValueFromConfig(serviceKey, option, config) {
        const configServiceKey = await this.getServiceOptionsFromConfig(serviceKey, config);
        if (!configServiceKey) {
            console.debug("Service with name " + serviceKey + " not found in config");
            return undefined;
        }
        // Find matching option key in the service config
        const optionValue = configServiceKey.options.find((o)=>o.name === option);
        return optionValue ? optionValue.value : undefined;
    }
    _updateOrAddOption(existingOptions, newOption) {
        const existingOptionIndex = existingOptions.findIndex((item)=>item.name === newOption.name);
        if (existingOptionIndex !== -1) // Update existing option
        return existingOptions.map((item, index)=>index === existingOptionIndex ? {
                ...item,
                value: newOption.value
            } : item);
        else // Add new option
        return [
            ...existingOptions,
            {
                name: newOption.name,
                value: newOption.value
            }
        ];
    }
    /**
     * Returns config with updated option(s) for specified service key and option name
     * Note: does not update current config, only returns a new object (call updateConfig to apply changes)
     * @param serviceKey - Service name to get options for (e.g. "llm")
     * @param option - Service name to get options for (e.g. "model")
     * @param config - Optional RTVIClientConfigOption[] to update (vs. using current config)
     * @returns Promise<RTVIClientConfigOption[] | undefined> - Configuration options array with updated option(s) or undefined
     */ async setServiceOptionInConfig(serviceKey, option, config) {
        const newConfig = (0, $8c5bX$clonedeep)(config ?? await this.getConfig());
        const serviceOptions = await this.getServiceOptionsFromConfig(serviceKey, newConfig);
        if (!serviceOptions) {
            console.debug("Service with name '" + serviceKey + "' not found in config");
            return newConfig;
        }
        const optionsArray = Array.isArray(option) ? option : [
            option
        ];
        for (const opt of optionsArray){
            const existingItem = newConfig.find((item)=>item.service === serviceKey);
            const updatedOptions = existingItem ? this._updateOrAddOption(existingItem.options, opt) : [
                {
                    name: opt.name,
                    value: opt.value
                }
            ];
            if (existingItem) existingItem.options = updatedOptions;
            else newConfig.push({
                service: serviceKey,
                options: updatedOptions
            });
        }
        return newConfig;
    }
    /**
     * Returns config object with updated properties from passed array.
     * @param configOptions - Array of RTVIClientConfigOption[] to update
     * @param config? - Optional RTVIClientConfigOption[] to update (vs. using current config)
     * @returns Promise<RTVIClientConfigOption[]> - Configuration options
     */ async setConfigOptions(configOptions, config) {
        let accumulator = (0, $8c5bX$clonedeep)(config ?? await this.getConfig());
        for (const configOption of configOptions)accumulator = await this.setServiceOptionInConfig(configOption.service, configOption.options, accumulator) || accumulator;
        return accumulator;
    }
    // ------ Actions
    /**
     * Dispatch an action message to the bot or http single-turn endpoint
     */ async action(action) {
        return this._messageDispatcher.dispatchAction(new (0, $bff4129f8f902365$export$378529d7a8bead8b)(action), this.handleMessage.bind(this));
    }
    /**
     * Describe available / registered actions the bot has
     * @returns Promise<unknown> - Promise that resolves with the bot's actions
     */ async describeActions() {
        return this._messageDispatcher.dispatch((0, $bff4129f8f902365$export$69aa9ab0334b212).describeActions());
    }
    // ------ Transport methods
    /**
     * Get the session expiry time for the transport session (if applicable)
     * @returns number - Expiry time in milliseconds
     */ get transportExpiry() {
        return this._transport.expiry;
    }
    // ------ Messages
    /**
     * Directly send a message to the bot via the transport
     * @param message - RTVIMessage object to send
     */ sendMessage(message) {
        this._transport.sendMessage(message);
    }
    handleMessage(ev) {
        console.debug("[RTVI Message]", ev);
        switch(ev.type){
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).BOT_READY:
                clearTimeout(this._handshakeTimeout);
                this._startResolve?.(ev.data);
                this._options.callbacks?.onBotReady?.(ev.data);
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).CONFIG_AVAILABLE:
                this._messageDispatcher.resolve(ev);
                this._options.callbacks?.onConfigDescribe?.(ev.data);
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).CONFIG:
                {
                    const resp = this._messageDispatcher.resolve(ev);
                    this._options.callbacks?.onConfig?.(resp.data.config);
                    break;
                }
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).ACTIONS_AVAILABLE:
                this._messageDispatcher.resolve(ev);
                this._options.callbacks?.onActionsAvailable?.(ev.data);
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).ACTION_RESPONSE:
                this._messageDispatcher.resolve(ev);
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).ERROR_RESPONSE:
                {
                    const resp = this._messageDispatcher.reject(ev);
                    this._options.callbacks?.onMessageError?.(resp);
                    break;
                }
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).ERROR:
                this._options.callbacks?.onError?.(ev);
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).USER_STARTED_SPEAKING:
                this._options.callbacks?.onUserStartedSpeaking?.();
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).USER_STOPPED_SPEAKING:
                this._options.callbacks?.onUserStoppedSpeaking?.();
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).BOT_STARTED_SPEAKING:
                this._options.callbacks?.onBotStartedSpeaking?.();
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).BOT_STOPPED_SPEAKING:
                this._options.callbacks?.onBotStoppedSpeaking?.();
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).USER_TRANSCRIPTION:
                {
                    const TranscriptData = ev.data;
                    this._options.callbacks?.onUserTranscript?.(TranscriptData);
                    break;
                }
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).BOT_TRANSCRIPTION:
                this._options.callbacks?.onBotTranscript?.(ev.data);
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).BOT_LLM_TEXT:
                this._options.callbacks?.onBotLlmText?.(ev.data);
                this._options.callbacks?.onBotText?.(ev.data); // @deprecated
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).BOT_LLM_STARTED:
                this._options.callbacks?.onBotLlmStarted?.();
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).BOT_LLM_STOPPED:
                this._options.callbacks?.onBotLlmStopped?.();
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).BOT_TTS_TEXT:
                this._options.callbacks?.onBotTtsText?.(ev.data);
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).BOT_TTS_STARTED:
                this._options.callbacks?.onBotTtsStarted?.();
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).BOT_TTS_STOPPED:
                this._options.callbacks?.onBotTtsStopped?.();
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).METRICS:
                this.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).Metrics, ev.data);
                this._options.callbacks?.onMetrics?.(ev.data);
                break;
            case (0, $bff4129f8f902365$export$38b3db05cbf0e240).STORAGE_ITEM_STORED:
                this._options.callbacks?.onStorageItemStored?.(ev.data);
                break;
            default:
                {
                    let match = false;
                    // Pass message to registered helpers
                    for (const helper of Object.values(this._helpers))if (helper.getMessageTypes().includes(ev.type)) {
                        match = true;
                        helper.handleMessage(ev);
                    }
                    if (!match) this._options.callbacks?.onGenericMessage?.(ev.data);
                }
        }
    }
    // ------ Helpers
    /**
     * Register a new helper to the client
     * This (optionally) provides a way to reference helpers directly
     * from the client and use the event dispatcher
     * @param service - Target service for this helper
     * @param helper - Helper instance
     * @returns RTVIClientHelper - Registered helper instance
     */ registerHelper(service, helper) {
        if (this._helpers[service]) throw new Error(`Helper with name '${service}' already registered`);
        // Check helper is instance of RTVIClientHelper
        if (!(helper instanceof (0, $505461462111ea0b$export$23bc637255b2a471))) throw new Error(`Helper must be an instance of RTVIClientHelper`);
        helper.service = service;
        helper.client = this;
        this._helpers[service] = helper;
        return this._helpers[service];
    }
    getHelper(service) {
        const helper = this._helpers[service];
        if (!helper) {
            console.debug(`Helper targeting service '${service}' not found`);
            return undefined;
        }
        return helper;
    }
    unregisterHelper(service) {
        if (!this._helpers[service]) return;
        delete this._helpers[service];
    }
    // ------ Deprecated
    /**
     * @deprecated use connect() instead
     */ async start() {
        return this.connect();
    }
    /**
     * @deprecated use getConfig instead
     * @returns Promise<RTVIClientConfigOption[]> - Promise that resolves with the bot's configuration
     */ async getBotConfig() {
        console.warn("VoiceClient.getBotConfig is deprecated. Use getConfig instead.");
        return this.getConfig();
    }
    /**
     * @deprecated This getter is deprecated and will be removed in future versions. Use getConfig instead.
     * Current client configuration
     * For the most up-to-date configuration, use getBotConfig method
     * @returns RTVIClientConfigOption[] - Array of configuration options
     */ get config() {
        console.warn("VoiceClient.config is deprecated. Use getConfig instead.");
        return this._options.config;
    }
    /**
     * Get registered services from voice client constructor options
     * @deprecated Services not accessible via the client instance
     */ get services() {
        console.warn("VoiceClient.services is deprecated.");
        return this._options.services;
    }
    /**
     * @deprecated Services not accessible via the client instance
     */ set services(services) {
        console.warn("VoiceClient.services is deprecated.");
        if (![
            "authenticating",
            "connecting",
            "connected",
            "ready"
        ].includes(this._transport.state)) this._options.services = services;
        else throw new $08bedc6ef0d1c66c$export$59b4786f333aac02("Cannot set services while transport is connected");
    }
}
$74c1449bc91bda44$var$__decorate([
    (0, $9e3641858ff8efee$export$f1586721024c4dab)
], $74c1449bc91bda44$export$fa42a01c1d60f4a1.prototype, "getConfig", null);
$74c1449bc91bda44$var$__decorate([
    (0, $9e3641858ff8efee$export$f1586721024c4dab)
], $74c1449bc91bda44$export$fa42a01c1d60f4a1.prototype, "updateConfig", null);
$74c1449bc91bda44$var$__decorate([
    (0, $9e3641858ff8efee$export$f1586721024c4dab)
], $74c1449bc91bda44$export$fa42a01c1d60f4a1.prototype, "describeConfig", null);
$74c1449bc91bda44$var$__decorate([
    (0, $9e3641858ff8efee$export$f1586721024c4dab)
], $74c1449bc91bda44$export$fa42a01c1d60f4a1.prototype, "describeActions", null);
$74c1449bc91bda44$var$__decorate([
    (0, $9e3641858ff8efee$export$5c35b4fe6fa8c9a6)("connected", "ready")
], $74c1449bc91bda44$export$fa42a01c1d60f4a1.prototype, "transportExpiry", null);
$74c1449bc91bda44$var$__decorate([
    (0, $9e3641858ff8efee$export$f1586721024c4dab)
], $74c1449bc91bda44$export$fa42a01c1d60f4a1.prototype, "sendMessage", null);
$74c1449bc91bda44$var$__decorate([
    (0, $9e3641858ff8efee$export$f1586721024c4dab)
], $74c1449bc91bda44$export$fa42a01c1d60f4a1.prototype, "getBotConfig", null);





var $4a333e41af7a850f$exports = {};

$parcel$export($4a333e41af7a850f$exports, "LLMMessageType", () => $4a333e41af7a850f$export$441bcd2e10762760);
$parcel$export($4a333e41af7a850f$exports, "LLMHelper", () => $4a333e41af7a850f$export$3cf39a62d076dd5c);




var $4a333e41af7a850f$export$441bcd2e10762760;
(function(LLMMessageType) {
    LLMMessageType["LLM_FUNCTION_CALL"] = "llm-function-call";
    LLMMessageType["LLM_FUNCTION_CALL_START"] = "llm-function-call-start";
    LLMMessageType["LLM_FUNCTION_CALL_RESULT"] = "llm-function-call-result";
    LLMMessageType["LLM_JSON_COMPLETION"] = "llm-json-completion";
})($4a333e41af7a850f$export$441bcd2e10762760 || ($4a333e41af7a850f$export$441bcd2e10762760 = {}));
class $4a333e41af7a850f$export$3cf39a62d076dd5c extends (0, $505461462111ea0b$export$23bc637255b2a471) {
    constructor(options){
        super(options);
        this._functionCallCallback = null;
    }
    getMessageTypes() {
        return Object.values($4a333e41af7a850f$export$441bcd2e10762760);
    }
    // --- Actions
    /**
     * Retrieve the bot's current LLM context.
     * @returns Promise<LLMContext>
     */ async getContext() {
        if (this._client.state !== "ready") throw new $08bedc6ef0d1c66c$export$885fb96b850e8fbb("getContext called while transport not in ready state");
        const actionResponseMsg = await this._client.action({
            service: this._service,
            action: "get_context"
        });
        return actionResponseMsg.data.result;
    }
    /**
     * Update the bot's LLM context.
     * If this is called while the transport is not in the ready state, the local context will be updated
     * @param context LLMContext - The new context
     * @param interrupt boolean - Whether to interrupt the bot, or wait until it has finished speaking
     * @returns Promise<boolean>
     */ async setContext(context, interrupt = false) {
        if (this._client.state !== "ready") throw new $08bedc6ef0d1c66c$export$885fb96b850e8fbb("setContext called while transport not in ready state");
        const actionResponse = await this._client.action({
            service: this._service,
            action: "set_context",
            arguments: [
                {
                    name: "messages",
                    value: context.messages
                },
                {
                    name: "interrupt",
                    value: interrupt
                }
            ]
        });
        return !!actionResponse.data.result;
    }
    /**
     * Append a new message to the LLM context.
     * If this is called while the transport is not in the ready state, the local context will be updated
     * @param context LLMContextMessage
     * @param runImmediately boolean - wait until pipeline is idle before running
     * @returns boolean
     */ async appendToMessages(context, runImmediately = false) {
        if (this._client.state !== "ready") throw new $08bedc6ef0d1c66c$export$885fb96b850e8fbb("setContext called while transport not in ready state");
        const actionResponse = await this._client.action({
            service: this._service,
            action: "append_to_messages",
            arguments: [
                {
                    name: "messages",
                    value: [
                        context
                    ]
                },
                {
                    name: "run_immediately",
                    value: runImmediately
                }
            ]
        });
        return !!actionResponse.data.result;
    }
    /**
     * Run the bot's current LLM context.
     * Useful when appending messages to the context without runImmediately set to true.
     * Will do nothing if the bot is not in the ready state.
     * @param interrupt boolean - Whether to interrupt the bot, or wait until it has finished speaking
     * @returns Promise<unknown>
     */ async run(interrupt = false) {
        if (this._client.state !== "ready") return;
        return this._client.action({
            service: this._service,
            action: "run",
            arguments: [
                {
                    name: "interrupt",
                    value: interrupt
                }
            ]
        });
    }
    // --- Handlers
    /**
     * If the LLM wants to call a function, RTVI will invoke the callback defined
     * here. Whatever the callback returns will be sent to the LLM as the function result.
     * @param callback
     * @returns void
     */ handleFunctionCall(callback) {
        this._functionCallCallback = callback;
    }
    handleMessage(ev) {
        switch(ev.type){
            case $4a333e41af7a850f$export$441bcd2e10762760.LLM_JSON_COMPLETION:
                this._options.callbacks?.onLLMJsonCompletion?.(ev.data);
                this._client.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).LLMJsonCompletion, ev.data);
                break;
            case $4a333e41af7a850f$export$441bcd2e10762760.LLM_FUNCTION_CALL:
                {
                    const d = ev.data;
                    this._options.callbacks?.onLLMFunctionCall?.(ev.data);
                    this._client.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).LLMFunctionCall, ev.data);
                    if (this._functionCallCallback) {
                        const fn = {
                            functionName: d.function_name,
                            arguments: d.args
                        };
                        if (this._client.state === "ready") this._functionCallCallback(fn).then((result)=>{
                            this._client.sendMessage(new (0, $bff4129f8f902365$export$69aa9ab0334b212)($4a333e41af7a850f$export$441bcd2e10762760.LLM_FUNCTION_CALL_RESULT, {
                                function_name: d.function_name,
                                tool_call_id: d.tool_call_id,
                                arguments: d.args,
                                result: result
                            }));
                        });
                        else throw new $08bedc6ef0d1c66c$export$885fb96b850e8fbb("Attempted to send a function call result from bot while transport not in ready state");
                    }
                    break;
                }
            case $4a333e41af7a850f$export$441bcd2e10762760.LLM_FUNCTION_CALL_START:
                {
                    const e = ev.data;
                    this._options.callbacks?.onLLMFunctionCallStart?.(e.function_name);
                    this._client.emit((0, $cbe8e0de0049ed6e$export$6b4624d233c61fcb).LLMFunctionCallStart, e.function_name);
                    break;
                }
        }
    }
}



var $2665d8e6d1596258$exports = {};

$parcel$export($2665d8e6d1596258$exports, "Transport", () => $2665d8e6d1596258$export$86495b081fef8e52);
class $2665d8e6d1596258$export$86495b081fef8e52 {
    constructor(){
        this._state = "disconnected";
        this._expiry = undefined;
    }
    get expiry() {
        return this._expiry;
    }
}




export {$d881613f2029ce0c$export$8728b60ea57bf43e as httpActionGenerator, $74c1449bc91bda44$export$fa42a01c1d60f4a1 as RTVIClient, $08bedc6ef0d1c66c$export$59b4786f333aac02 as RTVIError, $08bedc6ef0d1c66c$export$c67992fa684a81a6 as ConnectionTimeoutError, $08bedc6ef0d1c66c$export$e7544ab812238a61 as StartBotError, $08bedc6ef0d1c66c$export$e0624a511a2c4e9 as TransportStartError, $08bedc6ef0d1c66c$export$885fb96b850e8fbb as BotNotReadyError, $08bedc6ef0d1c66c$export$4eda4fd287fbbca5 as ConfigUpdateError, $08bedc6ef0d1c66c$export$975d7330b0c579b7 as VoiceError, $cbe8e0de0049ed6e$export$6b4624d233c61fcb as RTVIEvent, $505461462111ea0b$export$23bc637255b2a471 as RTVIClientHelper, $4a333e41af7a850f$export$441bcd2e10762760 as LLMMessageType, $4a333e41af7a850f$export$3cf39a62d076dd5c as LLMHelper, $bff4129f8f902365$export$882b13c7fda338f5 as RTVI_MESSAGE_LABEL, $bff4129f8f902365$export$38b3db05cbf0e240 as RTVIMessageType, $bff4129f8f902365$export$69aa9ab0334b212 as RTVIMessage, $bff4129f8f902365$export$28ad8d0d400d3e2d as RTVI_ACTION_TYPE, $bff4129f8f902365$export$378529d7a8bead8b as RTVIActionRequest, $bff4129f8f902365$export$e9a960646cc432aa as MessageDispatcher, $bff4129f8f902365$export$3336fb47fe34a146 as VoiceMessage, $2665d8e6d1596258$export$86495b081fef8e52 as Transport};
//# sourceMappingURL=index.module.js.map
